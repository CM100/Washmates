/*globals Parse, exports, require */
/**
 * @class Stripe
 * @static
 */
var cloud = require('cloud/cloud');
var roleManager = require('cloud/roleManager');
var errors = require('cloud/Utils/errors');
var logger = require('cloud/Utils/logger');
var Stripe = require('stripe');
var StripeAmount = require('cloud/Stripe/amount').Ctor;
var discountCode = require('cloud/DiscountCode/discount');
var _ = require('underscore');



/**
 * Creates a stripe customer for a user and saves the ID to the database for future use.
 * In case the user is already stripe customer adds the new card to its stripe customer account.
 * 
 * @method createStripeCustomer
 * @param {String} creditCardToken The token generated by stripe for a specific credit card.
 */
Parse.Cloud.define("createStripeCustomer", function createStripeCustomer(request, response) {
	Parse.Cloud.useMasterKey();

	var user = request.user;
	var creditCardToken = request.params.creditCardToken;
	if (user.get('isStripeClient')) {
		logger.info("User " + user.id + " is already stripe customer. Adding credit card to his account.");
		logger.info('Getting user ' + user.id + ' stripe meta');
		getUserStripeMetaAsync(user)
			.fail(function (error) {
				logger.warn('An error occured while trying to retrieve stripe meta for user ' + user.id);
				logger.error(error);
				response.error(error);
			})
			.done(function (userStripeMeta) {
				return Stripe.Customers.createSource(userStripeMeta.get('stripeCustomerId'), {
					source: creditCardToken
				});
			})
			.done(function (creditCardResponse) {
				response.success(creditCardResponse);
			})
			.fail(function (error) {
				logger.warn('An error occured while trying to add credit card with token ' + creditCardToken + ' to user ' + user.id);
				logger.error(error);
				response.error(error);
			});
	} else {
		logger.info('Creating stripe customer for user ' + user.id);
		Stripe.Customers.create({
				source: creditCardToken,
				email: user.get('email'),
				description: 'Cleanium customer'
			})
			.done(function saveCustomerId(customer) {
				logger.info('Customer created on stripe with id ' + customer.id + ' for user ' + user.id);
				var stripeMeta = new Parse.Object('StripeMeta');
				stripeMeta.set('user', user);
				stripeMeta.set('stripeCustomerId', customer.id);
				return stripeMeta.save();
			})
			.done(response.success)
			.fail(function (error) {
				logger.warn('Failed to create stripe customer with error ' + JSON.stringify(error));
				logger.error(error);
				response.error(errors.getErrorResponse(error));
			});
	}

});


/**
 * Listing all stripe cards available to a user. User required to be stripe customer already.
 * In the process removes any expired card the user may have.
 * 
 * @method listStripeCards
 * @returns {Array}    An array with all the valid stripe cards of the user.
 */
Parse.Cloud.define("listCards", function listStripeCards(request, response) {
	var user = request.user;

	if (!user.get('isStripeClient')) {
		response.error(errors.USER_NOT_STRIPE_CUSTOMER);
	}

	logger.info('Attempting to list all cards for user ' + user.id);

	getUserStripeMetaAsync(user)
		.fail(function (error) {
			response.error(errors.getErrorResponse(error));
		})
		.done(function (stripeUserMeta) {
			return Stripe.Customers.listCards(stripeUserMeta.get('stripeCustomerId'));
		})
		.done(function (stripeCardsResponse) {
			return removeAnyExpiredCardsAsync(stripeCardsResponse.data);
		})
		.done(function (validCards) {
			response.success(validCards || []);
		})
		.fail(function (error) {
			response.error(error);
		});
});


/**
 * Changes the user's default card to the one of his choice. The default card is the one
 * the user added first.
 * 
 * @method selectDefaultCard
 * @param {Object|String} card     The card to be set default payment card. Can be either 
 *                                 the id of the card or the card object as per Stripe 
 *                                 response of a card object.
 */
Parse.Cloud.define('selectDefaultCard', function selectDefaultCard(request, response) {
	if (!request.params.card) {
		response.error(errors.INVALID_ARGUMENT);
	}
	var user = request.user;

	var selectedCardId = request.params.card.id || request.params.card;

	logger.info('Attempting to select as default the card with id ' + selectedCardId + ' for user ' + user.id);

	getUserStripeMetaAsync(user)
		.fail(function (error) {
			logger.warn('Error while retrieving stripe meta for user ' + user.id + '. Error: ' + JSON.stringify(error));
			logger.error(error);
			response.error(error);
		})
		.done(function (stripeUserMeta) {
			return Stripe.Customers.update(stripeUserMeta.get('stripeCustomerId'), {
				default_source: selectedCardId
			});
		})
		.done(function () {
			logger.info('Default card changed succesfully');
			response.success();
		})
		.fail(function (error) {
			logger.warn('Failed to update default card to ' + selectedCardId + ' for user ' + user.id + ' with error ' + JSON.stringify(error));
			logger.error(error);
			response.error(errors.getErrorResponse(error));
		})


});


/**
 * Removes the given credit card from stripe's customer account. 
 * 
 * @method removeCard
 * @param {Object|String} card     The card object as per stripe's credit card response 
 *                                 or the credit card id of the card to be deleted.
 */
Parse.Cloud.define('removeCard', function removeCard(request, response) {
	if (!request.params.card) {
		response.error(errors.INVALID_ARGUMENT);
	}
	var user = request.user;
	var cardToRemoveId = request.params.card.id || request.params.card;

	logger.info('Attempting to remove card with id ' + cardToRemoveId + ', from user ' + user.id);

	getUserStripeMetaAsync(user)
		.fail(function (error) {
			logger.warn('Error while retrieving stripe meta for user ' + user.id + '. Error: ' + JSON.stringify(error));
			logger.error(error);
			response.error(error);
		})
		.done(function(stripeUserMeta){
			logger.info('Removing card ' + cardToRemoveId + 'for stripe customer ' + stripeUserMeta.get('stripeCustomerId'));
			return removeCreditCardAsync(stripeUserMeta.get('stripeCustomerId'), cardToRemoveId)
		})
		.done(function(stripeResponse){
			/*Example response:
				{
				  "deleted": true,
				  "id": "card_16OuTKLSNzOOoFpYMU1xEROo"
				}
			*/
			if( stripeResponse.deleted && stripeResponse.id === cardToRemoveId) {
				logger.info('The credit card with id ' + cardToRemoveId + ' succesfully removed.');
				response.success();				
			} else {
				logger.warn('The response was positive but the credit card with id ' + cardToRemoveId + ' failed to be removed. Response: ' + JSON.stringify(response));
				logger.error(response);
				response.error(errors.GENERIC_ERROR_RESPONSE);
			}
		})
		.fail(function(error){
			logger.warn('The credit card with id ' + cardToRemoveId + ' failed to be removed. Response: ' + JSON.stringify(response));
			logger.error(response);
			response.error(errors.getErrorResponse(error));
		})

});


/**
 * Allows the admin to refund an order. Params are send as a json object with the following properties:
 * 
 * @method refundOrder
 * @param {String} orderId The id of the order about to be rated.
 * @param {String} reason The reason for the refund.
 */
Parse.Cloud.define("refundOrder", function refundOrder(request, response) {
	Parse.Cloud.useMasterKey();
	var orderId = request.params.orderId;
	var refundReason = request.params.reason || 'Admin requested';
	var user = request.user;
	var order;

	if (!orderId || !_.isString(orderId)) {
		response.error(errors.INVALID_ARGUMENT);
	}

	roleManager.checkIfUserInRoles(user, roleManager.ADMIN_ROLE)
		.done(function (isAuthorized) {
			if (!isAuthorized) {
				logger.warn('User with ID ' + user.id + ' attempted to issue a non authorized refund for order ' + orderId);
				response.error(errors.REFUND_NOT_AUTHORIZED);
				return;
			}

			var orderQuery = new Parse.Query(Parse.Object.extend('Order'));
			orderQuery.include('payment');
			orderQuery.equalTo('objectId', orderId);
			return orderQuery.first();
		})
		.done(function (orderResponse) {
			order = orderResponse;
			if (!order) {
				response.error(errors.NO_DATA_FOUND);
			}
			if (!order.get('stripeTransactionID')) {
				response.error(errors.INVALID_ARGUMENT);
			}
			return Stripe.Charges.createRefund(
				order.get('stripeTransactionID'), {
					reason: refundReason
				}
			);
		})
		.done(function onRefundSuccess(refundResponse) {
			var payment = order.get('payment');
			payment.set('refundStripeTransactionID', refundResponse.id);
			return payment.save();
		})
		.fail(function onRefundError(error) {
			logger.warn('Error while attempting a refund for order ' + orderId + ' with reason ' + refundReason + ' from user ' + user.id);
			logger.error(error);
			response.error(errors.getErrorResponse(error));
		});
});


/**
 * Allows the user to make a payment. Params are send as a json object on `request.params` with the following properties:
 * 
 * @method chargeOrder
 * @param {String|Object} order     The order be charged. Can be the id as a string or an Order Parse.Object
 * @param {Number} amount[amount=1] The amount to be charged. Minimum value is 0.5$.
 */
Parse.Cloud.define("chargeOrder", function chargeOrder(request, response) {
	Parse.Cloud.useMasterKey();

	var userRequestedCharge, order;

	order = request.params.order;
	userRequestedCharge = request.user;

	logger.info('Cloud function chargeOrder has been invocked by user ' + userRequestedCharge.id + ' for order ' + order.id || order);
	var orderQuery = new Parse.Object.extend('Order');
	orderQuery.include('user');
	orderQuery.include('discountCode');
	orderQuery.equalsTo('objectId', request.params.order);
	orderQuery.first()
		.done(function (orderResponse) {
			if (!orderResponse) {
				logger.warning('Non existing order requested to be charged with id ' + order);
				response.error(errors.NO_DATA_FOUND);
				return;
			}
			if (orderResponse.get('payment')) {
				logger.warning('Attempted to charge an already already charged. Aborting');
				response.error(errors.CHARGE_ALREADY_OCCURED);
			}
			order = orderResponse;
			return roleManager.checkIfUserInRoles(userRequestedCharge, roleManager.ADMIN_ROLE)
		})
		.done(function authorizeUserAndPay(isAdmin) {
			if (!isAdmin || order.get('user').id !== userRequestedCharge) {
				logger.warn('Anauthorized charge attempted by user: ' + userRequestedCharge.id + '.')
				response.error(errors.CHARGE_NOT_AUTHORIZED);
			}
			logger.info('User allowed to make a payment. Issuing payment now.')
			return exports.chargeOrder(order);
		})
		.done(function (paymentInfo) {
			logger.info('Payment completed. Payment Id :' + paymentInfo.id);
			order.set('payment', paymentInfo);
			return order.save();
		})
		.done(function (order) {
			logger.info('Payment attached to order ' + order.id);
			response.success(order);
		})
		.fail(function (error) {
			logger.warn('Charge user for order ' + order.id + ' failed with error ' + JSON.stringify(error));
			logger.error(error);
			response.error(errors.getErrorResponse(error));
		});
});


function getUserStripeMetaAsync(user) {
	var customerQuery = new Parse.Query(Parse.Object.extend('StripeMeta'));
	customerQuery.equalTo('user', user);
	return customerQuery.first()
		.done(function (result) {
			if (!result) {
				return Parse.Promise.error(errors.NO_DATA_FOUND);
			}
			return Parse.Promise.as(result);
		})
		.fail(function (error) {
			logger.warn('Error querying for stripeMeta based on user id ' + user.id);
			logger.error(error);
			return Parse.Promise.error(error);
		});
}

function removeAnyExpiredCardsAsync(allUserCards) {
	if (!allUserCards.length) {
		return Parse.Promise.as([]);
	}
	logger.info('Checking user credit cards for expired cards');
	var now = new Date();
	var currentMonth = now.getMonth() + 1; //Months start from 0
	var currentYear = now.getYear() + 1900 //Years offset is 1900.
	var expiredCards = _.filter(allUserCards, function (creditCard) {
		return creditCard.exp_year <= currentYear && creditCard.exp_month < currentMonth;
	});
	var validCards = allUserCards;
	var stripeCustomerId = allUserCards[0].customer; //Getting the customer id from creditCard data.
	var cardsDeleted = [];



	if (expiredCards.length) {
		logger.info(expiredCards.length + ' found.');
		expiredCards.forEach(function (expiredCard) {
			logger.info('Removing credit card with id ' + expiredCard.id + ' from stripe customer with id ' + stripeCustomerId);
			cardsDeleted.push(removeCreditCardAsync(stripeCustomerId, expiredCard.id));
			validCards = _.without(validCards, _.findWhere(validCards, {
				id: expiredCard.id
			}));
		});
	}

	var removedExpiredCardsPromise = new Parse.Promise();

	Parse.Promise.when(cardsDeleted)
		.done(function () {
			removedExpiredCardsPromise.resolve(validCards);
		})
		.fail(removedExpiredCardsPromise.reject);

	return removedExpiredCardsPromise;
}

function removeCreditCardAsync(stripeCustomerId, creditCardId) {
	return Stripe.Customers.deleteCard(stripeCustomerId, creditCardId)
		.fail(function (error) {
			logger.warn('Attempted to remove card with id ' + creditCardId + ' from stripe and failed with error: ' + JSON.stringify(error));
			logger.error(error);
			return Parse.Promise.error(error);
		});
}

function chargeStripeUserAsync(stripeUserMeta, amountCharged) {
	var stripeAmountCharged = new StripeAmount(amountCharged);
	if (!stripeUserMeta) {
		logger.info('Attempted to charge a user who is not stripe customer (has not set credit card info)');
		return Parse.Promise.error(new Error(errors.USER_NOT_STRIPE_CUSTOMER));
	}

	if (!stripeAmountCharged.isValid) {
		logger.error('The amount to be charged is invalid. ' + amountCharged.errorMessage);
		return Parse.Promise.error(new Error(amountCharged.errorMessage));
	}

	logger.info('About to create a charge for ' + stripeUserMeta.get('user').id + ' with customer id ' + stripeUserMeta.get('stripeCustomerId'));
	
	logger.debug({
		amount: stripeAmountCharged, 
		currency: "usd",
	});
	return Stripe.Charges.create({
			amount: stripeAmountCharged, // amount in cents, again
			currency: "usd",
			customer: stripeUserMeta.get('stripeCustomerId'),
			statement_descriptor: "Washmates"
		})
		.fail(function (error) {
			logger.warn('Error trying to charge a user');
			logger.error(error);
			return Parse.Promise.error(error);
		});
}


function calculateChargeAmountAsync(order) {
	return order.relation("services").query().find()
		.done(function (services) {
			logger.log('The available services found are: ' + JSON.stringify(services));
			var paymenentReceipt = {
				discount: {},
				services: [],
				total: 0
			};
			var amountCharged;
			var discount = order.get('discountCode');
			var amount = _.reduce(services, function (totalAmount, service) {
				var quantity = service.get('quantity') || 1;
				var total = totalAmount + (service.get('price') * quantity);

				paymenentReceipt.services.push({
					title: service.get('title'),
					quantity: quantity,
					price: service.get('price')
				});

				logger.debug('Calculating for service quantity of ' + quantity + ' for price ' + service.get('price'));

				return total;
			}, 0);

			paymenentReceipt.total = amount;

			logger.info('The base amount is ' + amount);

			if (discount) {
				logger.info('Discount exists. Calculating...');
				return discountCode.calculateDiscountAmountAsync(discount, amountCharged)
					.done(function (discountAmount) {
						amountCharged = amount - discountAmount;
						paymenentReceipt.discount.code = discount;
						paymenentReceipt.discount.amount = discountAmount;
						paymenentReceipt.total = amountCharged;
						order.set('paymentReceipt', paymenentReceipt);

						if (amountCharged < 0) {
							logger.warn('The amount charged has a negative value after discount. Setting it to 0');
							amountCharged = 0;
						}
						return Parse.Promise.as(amountCharged);
					});
			} else {
				amountCharged = amount;
			}

			order.set('paymentReceipt', paymenentReceipt);
			return Parse.Promise.as(amountCharged);
		})
		.fail(function (error) {
			logger.warn('Error calculating amount for order ' + order.id);
			logger.error(error);
			return Parse.Promise.error(error);
		});
}



exports.chargeOrder = function chargeOrder(order) {
	Parse.Cloud.useMasterKey();
	var amountCharged = 0,
		userCharged = order.get('user');

	logger.info('Charging order ' + order.id);

	if (order.get('user').get('isStripeClient') !== true) {
		logger.warn('Payment requested for user without credit card info');
		return Parse.Promise.error(new Error(errors.USER_HAS_NO_CC_DATA));
	}

	if (order.get('payment') && order.get('payment').get('refundStripeTransactionID')) {
		return Parse.Promise.as(order.get('payment'));
	}

	return Parse.Promise.when([calculateChargeAmountAsync(order), getUserStripeMetaAsync(userCharged)])
		.done(function chargeUser(chargedAmount, userStripeMeta) {
			amountCharged = chargedAmount;
			return chargeStripeUserAsync(userStripeMeta, amountCharged);
		})
		.done(function savePaymentInfo(charge) {
			if (!charge.paid || charge.status !== "succeeded") {
				return Parse.Promise.error(new Error(errors.getStripeErrorsFromCharge(charge)));
			}
			var paymentInfo = new(Parse.Object.extend('Payment'))();
			paymentInfo.set('user', userCharged);
			paymentInfo.set('amount', charge.amount);
			paymentInfo.set('stripeTransactionID', charge.id);
			paymentInfo.set('order', order);
			return paymentInfo.save();
		})
		.fail(function (error) {
			logger.warn('Error trying to create and save a payment to Parse');
			logger.error(error);
			return Parse.Promise.error(error);
		});
};



exports.applyHooks = function () {

	cloud.afterSave('StripeMeta', function applyStripeMetaAfterSaveHooks(request, response) {
		Parse.Cloud.useMasterKey();
		var stripeMetaUser = request.object.get('user');


		logger.log('User ' + JSON.stringify(stripeMetaUser));

		var user = new Parse.User();
		user.id = request.object.get('user').id;
		user.set('isStripeClient', true);
		user.set('skipWebHooks', true);
		user.save();

		var stripeMetaRestrictions = {};
		stripeMetaRestrictions[roleManager.MEMBER_ROLE] = [];
		stripeMetaRestrictions[roleManager.PUBLIC_ROLE] = [];
		stripeMetaRestrictions[roleManager.LAUNDRY_ROLE] = [];
		stripeMetaRestrictions[roleManager.DRIVER_ROLE] = [];
		stripeMetaRestrictions[roleManager.ADMIN_ROLE] = [roleManager.READ_ACCESS];
		roleManager.setPrivateAccess(null, request.object, stripeMetaRestrictions);
	});

	cloud.afterSave('Payment', function applyPaymentAfterSaveHooks(request, response) {
		var userRequestedPayment = request.object.get('user');

		var payementRestrictions = {};
		payementRestrictions[roleManager.SELF_ROLE] = [];
		payementRestrictions[roleManager.MEMBER_ROLE] = [];
		payementRestrictions[roleManager.PUBLIC_ROLE] = [];
		payementRestrictions[roleManager.LAUNDRY_ROLE] = [roleManager.READ_ACCESS];
		payementRestrictions[roleManager.DRIVER_ROLE] = [];
		payementRestrictions[roleManager.ADMIN_ROLE] = [roleManager.READ_ACCESS];

		roleManager.setPrivateAccess(userRequestedPayment, request.object, payementRestrictions);
		// 
	});
};

exports.init = function initializeStripe(config) {
	Stripe.initialize('sk_test_Jiu0xI2koZqiMl9V0IWcloGd');
	this.applyHooks();
};